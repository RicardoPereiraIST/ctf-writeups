import codecs

e = 65537
n = 352758655756163603130656475864162239004344663459120398951306959672239055329877644796995008368282924624780849432051543118959312685532106237568240835778731486989439626252834661294225426875963944816709371554839452465119058016363040631618359944564550348310851045841670935254841385590882490443247265126417117450357
dp = 13530055667815347122266109008252377134325151556131892235929064596659462917644020624855537451062167377041847601387880412738836767351591511886432133011921729
c = 23428056833770750219439218340180501853506449797628734848807388355447212714387039203998085387476974936419607861041793755542930286287098871510394661091846780839592290953853536571372997807697657464569729651718518301857979495046280018444198435962234642736892075369840282923945267377104440625478468507147243879631

def gcd(x, y):
    while y != 0:
        (x, y) = (y, x % y)
    return x

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

def fermat_test(n):
	if n == 2:
		return True
	if not n & 1:
		return False
	return pow(2, n-1, n) == 1

p_1_multiple = dp*e - 1
p = 0
for kp in range(2, 100000000):
    print("kp =", kp)
    p = gcd(p_1_multiple + kp, n)
    if fermat_test(p) == True:
        print("Found p prime!")
        print(p)
        break

q = n // p

phi = (q - 1) * (p - 1)

d = modinv(e, phi)

m = pow(c, d, n)

print(codecs.decode((hex(m).replace("0x", "")), "hex"))